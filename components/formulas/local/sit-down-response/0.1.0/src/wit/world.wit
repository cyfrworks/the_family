package cyfr:formula@0.1.0;

interface run {
    /// Execute formula orchestration logic with JSON input, returning JSON output.
    run: func(input: string) -> string;
}

/// Host function for invoking sub-components from a Formula.
interface invoke {
    /// Invoke a sub-component synchronously. Request and response are JSON-encoded strings.
    /// Request: {"reference": {...}, "input": {...}, "type": "reagent|catalyst|formula"}
    /// Response: {"status": "completed", "output": {...}} or {"error": {...}}
    call: func(json-request: string) -> string;

    /// Launch multiple sub-component invocations in parallel.
    /// Request: {"invocations": [{"reference": {...}, "input": {...}, "type": "..."},...]}
    /// Response: {"batch": "<handle>", "count": N} or {"error": {...}}
    call-batch: func(json-request: string) -> string;

    /// Poll a single invocation result by index.
    /// Request: {"batch": "<handle>", "index": N}
    /// Response: {"status": "completed"|"pending"|"error", ...}
    poll: func(json-request: string) -> string;

    /// Poll all invocations in a batch.
    /// Request: {"batch": "<handle>"}
    /// Response: {"results": [...], "all_done": true|false}
    poll-all: func(json-request: string) -> string;

    /// Close a batch, killing any running invocations and freeing resources.
    /// Request: {"batch": "<handle>"}
    /// Response: {"ok": true} (always succeeds, idempotent)
    close: func(json-request: string) -> string;
}

world formula {
    export run;
    import invoke;
    import cyfr:mcp/tools@0.1.0;  // Optional: for dynamic MCP access
}
